---
title: "ggorder_heatmap function"
author: "Gertjan Verhoeven"
date: "22-10-2022"
output:
  md_document:
    variant: gfm
---

# ggoheatmap

The `ggorder_heatmap()` function plots a dataframe using `geom_tile()` where both x- and y plotting order can be provided as arguments.
It does not perform clustering of the data, this is performed separately to generate the sort order.
For example, sort order can be generated by the `hclust` set of algorithms.

Most R heatmap functions or packages combine clustering and plotting in a single function.
However, there are many ways to order the rows and columns of a dataset, and I felt that separating the clustering from the plotting makes things easier to use.

## install package
Use `devtools::install_github("gsverhoeven/ggoheatmap")` to install the package from Github.

## use package

```{r}
library(tidyverse)

library(ggoheatmap)
```

# Create an example dataset 

First we create a dataframe that corresponds to a 2 x 3 matrix of percentages.
`ggorder_heatmap()` requires data in the `long` format, suitable for `ggplot`.

A matrix or wide dataset needs to be converted first using `pivot_longer()`.

The dataframe contains two special columns: `col_order`, that specifies the plotting order of the x value, and `xlab`, the label of the x axis.

```{r}
df <- data.frame(x = c("a", "a", "c", "c", "b", "b"), 
                  y = c(1, 2, 1, 2, 1, 2), 
                  perc = c(1, 0.2, 0.3, 1, 1, 0.4), 
                  col_order = c(1, 1, 3, 3, 2, 2),
                  xlab = as.factor(c("Foo", "Foo", "Bar", "Bar", "Hello", "Hello")))

df
```

Next, we show first the default behavior, which is to plot the dataset "as is":

<!-- xlab_var = "xlab" does not work yet -->


```{r}
ggorder_heatmap(df, col_var = "perc")
```

Use the argument `order_var` to tell `ggorder_heatmap()` which column contains the sort order of the x axis.
`ggorder_heatmap()` returns a ggplot2 object that can be further modified using ggplot functions, i.e. by adding axis and title labels.

```{r}
ggorder_heatmap(df,
                col_var = "perc", 
                order_var = "col_order") + 
  labs(y = "Y value") +
  ggtitle("Now with ordered x axis")
```

We can order the y-axis as well by specifying the `yorder` argument.
Here we just use the negative of the y value as sort order directly.

```{r}
df$yorder <- -df$y

ggorder_heatmap(df,
                col_var = "perc", 
                order_var = "col_order",
                yorder_var = "yorder") + 
  labs(y = "Y value") +
  ggtitle("Now with ordered x and y axis")
```

# Hierarchical clustering with ggorder_heatmap

Now that we have a way to specify X- and Y sort orders, we can use clustering algorithms to produce sort orders for plotting.

For example, the package contains a function `hclust_order()` that adds a `cluster_order` column to our dataset based on hierarchical clustering using `hclust`. The function expects a dataset in the long form with default column names `x`, `y` and `value`. These values can be overridden by the  `xvar`, `yvar` and `value_var` arguments.

<!-- PM # check if dist_method "euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowski" also work  -->


```{r}
df_clust <- hclust_order(df, 
                         value_var = "perc",
                   clust_method = "complete",
                   dist_method = "euclidean")

df_clust
```

Here is the resulting heatmap using the hierarchical clustering on our example dataset:

```{r}
ggorder_heatmap(df_clust, 
                col_var = "perc", 
                order_var = "cluster_order") +
  ggtitle("Order column is now based on hierarchical clustering")
```

# Palmer penguins

Lets try it with a bigger dataset, `palmerpenguins`.

First we have to get it in a long format.

```{r}
library(palmerpenguins)

df <- penguins
df$row_id <- 1:nrow(df)

yorder_tab <- data.frame(yorder = c(1:4), 
                         variable = c("body_mass_g", "bill_length_mm", "bill_depth_mm", "flipper_length_mm"))

df_long <- df %>%
  slice_sample(n = 30) %>%
  pivot_longer(cols = !c(species, island, sex, row_id, year), names_to = "variable") %>%
  group_by(variable) %>%
  mutate(sd_value = scale(value)) %>%
  left_join(yorder_tab, by = "variable")
```

Let's plot all the (numeric) values of a random sample of 30 penguins:

```{r fig.width = 15, fig.height = 7}
ggorder_heatmap(df_long, xvar = "row_id", yvar = "variable",
                order_var = "row_id", 
                yorder_var = "yorder",
                col_var = "sd_value", label_var = "value", round.digits = 0) + 
  coord_flip() +
  ggtitle("30 Palmer penguins")

```
